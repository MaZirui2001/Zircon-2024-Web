# **分支预测**

Zircon-2024采用了结合预译码的多级分支预测技术。为了用尽可能少的资源获得可观的预测精度，每一个分支预测器都只使用了较小的容量和简单的逻辑。

## **BTBMini**

BTBMini是用来记录每一条分支指令的跳转目标地址的元件。其容量比较小，只能容下几十条指令的跳转目标地址。每一个BTBMini表项都由如下结构组成：

| 字段 | 位宽 | 描述 |
| --- | --- | --- |
| predType | 2 | 分支指令类型 |
| imm | 30 | 跳转目标地址 |
| pattern | 3 | 3位饱和计数器 |

每个周期，BTBMini会向分支预测器提供当前指令组内所有指令的两个信息：predType和jumpCandidate。其中predType是该指令的分支类型，而jumpCandidate用判断了一个指令组中有可能跳转的那条指令的位置。

由于每个指令组中可能都有多条指令会跳转，一个事实是，如果组内一条地址较小的指令跳转，那么组内地址大于它的指令的预测结果就都应该无效，但这里会存在一个问题：

* 假设指令A的地址低于指令B，且A和B处在同一组里，那么如果A在一段时间内频繁跳转，之后又频繁不跳转，那么在A不跳转的这段时间里，应该基于B的预测结果来预测指令组的跳转，但A依然存在于BTBMini中，如何决定指令组“听谁的结果”？

Zircon-2024的解决方案是，**在指令组内，采用简单的局部预测**。每一条指令都会有一个3位的PHT计数器，跳转时计数器加一，不跳转时计数器减一。当一条指令的计数器值大于等于4时，认为该指令可能跳转，并将其jumpCandidate置为1。实践证明，在分支组内决策时，这种3bit的pattern的效果要优于使用2bit的pattern。

## **GShare预测器**

GShare预测器是一种常见的精简的全局分支预测器，使用PC与全局历史的哈希的结果来索引2bit计数器，从而预测其是否跳转。

GShare在预测单条指令的结果时效果是比较可观的，但Zircon-2024需要一个周期预测多条指令的结果。David Patterson教授曾在论文中提及了一种对多条指令进行预测的方法，但方案是基于Cache可以在预测跳转的情况下跨行访问的事实，这对Zircon-2024来说是不适用的。因此，Zircon-2024的GShare只会基于一个指令组进行预测（即判断该指令组中是否至少有一条指令要跳转），而由BTB来给出该指令组中跳转指令的位置，并结合起来进行最终的分支预测。

为了提高GShare预测器的准确性，Zircon-2024在预译码器和提交段各自配备了一个全局历史寄存器。当预译码器冲刷流水线或提交段冲刷流水线时，分支预测器的全局历史预测器会被恢复为对应的寄存器。

## **Return Address Stack**

返回地址栈（RAS）是用于预测间接跳转指令的元件，基于函数调用和返回的LIFO特点来进行预测。当一条跳转指令被预测为函数调用指令时，RAS会将其地址压入栈中。而当一条指令被预测为返回指令时，RAS会从栈中弹出地址，并将其作为跳转目标。

在预译码和提交段，Zircon-2024分别配备了一个RAS。一旦分支预测器没有记录过一条返回指令，预译码器就会使用预译码段的RAS作为预测结果。如果预译码器或者提交段发起了冲刷，那么对应段的RAS会恢复到分支预测器的RAS中。

